# CISC2006 **Syllabus** 

# 算法课总共三道大题，第一题十个小判断题（复杂度什么的），第二道是AVL的增删、平衡，第三道是Dijkstra算法。
# 最小生成树，最短路径，图遍历，只要能写出过程就好了。算法有TF题，还挺诡异的，算时间复杂度，空间复杂度，还有（大O，大Ω，θ）等，让你判断。

## 算法复杂度

O 封顶，Ω 托底，θ 夹紧；

掌握一些对数运算公式：

Big O 是描述算法最坏情况下运行时间增长趋势的数学工具，只看“上界”，忽略常数和低阶项。

| 函数形式                         | 目标              | 选 c 思路               | 选 N 思路                | 一句话口诀       |
| ----------------------------   | --------------- | -------------------- | --------------------- | ----------- |
| **线性**<br>`kn + b`           | 证 `O(n)`        | `c = k + 1`          | `N = ⌈b/(c-k)⌉ = ⌈b⌉` | 系数加 1，常数即 N |
| **多项式**<br>`a n² + b n + d`  | 证 `O(n²)`       | `c = a + b + d`（系数和） | `N = 1` 即可            | 系数全加，N 取 1  |
| **多项式比大小**<br>`n³ vs n²`     | 证 `n³ ∉ O(n²)`  | 不存在                  | 反证：设存在，导出 `n ≤ c` 矛盾  | 指数大，永不等     |
| **对数/根号**<br>`n log n + 5n`  | 证 `O(n log n)`  | `c = 1 + 5`          | `N = 2`（log n ≥ 1）    | 低阶项系数相加     |
| **指数 vs 多项式**<br>`2ⁿ vs n^k` | 证 `2ⁿ ∉ O(n^k)` | 不存在                  | 极限 `2ⁿ/n^k → ∞`       | 指数永远赢       |

多项式：把所有系数加起来当 c，N 直接写 1。
例：3n² + 7n + 10 ∈ O(n²) → c = 3+7+10 = 20，N = 1
线性+常数：系数加 1，常数即 N。
例：4n + 7 ∈ O(n) → c = 5，N = 7
反证法：只要指数高一级，直接说“不成立”并写极限。


| 题目                          | 秒答         |
| ---------------------------  | ---------- |
| `5n³ + 100n ∈ O(n³)`        | c=105, N=1 |
| `2n + 9 ∈ O(n)`             | c=3, N=9   |
| `n⁴ ∈ O(n³)`                | ❌ 不成立，极限 ∞ |
| `n log n + 3n ∈ O(n log n)` | c=4, N=2   |



AVL 的插入流程：
LR 型：失衡节点是 z， 新插入的节点在 z 的左孩子的右子树里。这时候 z 的平衡因子 = 2（左子树太高），但 x 的平衡因子 = -1（右子树更高）
→ 所以叫 Left-Right，简称 LR：
左旋规则：把右孩子提上来，自己降下去做左孩子
右旋规则：把左孩子提上来，自己降下去做右孩子




## I. Binary Search Trees

### 1. Tree

#### 1.1 树的特征

1. 层次性：按层次分类，越上级越普遍
2. 独立性：子节点之间是互相独立、隔离的
3. 唯一性：每一个叶节点都有唯一性

#### 1.2 相关术语

1. 节点Node：组成树的基本部分，每个节点具有名称（键值），可以保存额外数据项
   - 子节点Children：入边均来自于同一节点的若干节点
   - 父节点Parent：一个节点是其所有出边所连接节点
   - 兄弟节点Sibling：具有同一父节点的节点集合
   - 根Root：树中唯一一个没有入边的节点
   - 叶节点Leaf：没有子节点的节点
2. 边Edge：每条边连接两个节点，每个节点（除根节点）都有来自另一节点的入边，每个节点（除叶节点）都有指向其他节点的出边
3. 路径Path：由边依次连接在一起的节点的有序列表
4. 子树Subtree：一个节点和其所有子孙节点及相关边的集合
5. 层级Level：从根节点开始到达一个节点的路径，所包含边的数量
6. 高度Height：树中所有节点的最大层级

#### 1.3 定义

##### 定义1

树由若干节点，以及两两连接节点的边组成，并有如下性质：

- 其中一个节点被设定为根
- 除根节点外的每个节点n都切有一条来自节点p的边，p是n的父节点
- 每个节点从根开始的路径是唯一的
- 如果每个节点最多有两个子节点，该树称为**二叉树**

##### 定义2（递归定义）

树是

- 空集；
- 或由根节点及0或多个子树构成，每个子树的根到根节点具有边相连

### 2 实现

#### 2.1 嵌套列表法实现

使用python中的list数据结构来实现二叉树结构：递归的嵌套列表，由具有3个元素的列表[root, left, right]实现

- 第一个元素为根节点的值root
- 第二个元素是左子树left
- 第三个元素是右子树right


#### 2.2 链表方式实现

每个节点保存根节点的数据项，以及指向左右子树的链接

<img src="/Users/rocher/Library/Application Support/typora-user-images/image-20240416182103414.png" alt="image-20240416182103414" style="zoom:40%;" />

算法分析：

- 定义一个BinaryTree类，成员key保存根节点数据项，成员left/rightChild则保存指向左右子树的引用（同样是BinaryTree对象）


### 3. 应用案例：表达式解析

使用树表示表达式，例如下图计算$(7+3)\times(5-2)$:

<img src="/Users/rocher/Library/Application Support/typora-user-images/image-20240416185943526.png" alt="image-20240416185943526" style="zoom:40%;" />

树中的每个子树都表示一个子表达式，将该子树替换成子表达式值的节点，即可实现求值

任务目标：

- 从全括号表达式构建解析树
- 利用解析树对表达式求值
- 从解析树恢复原表达式的全括号字符串形式

算法分析：

1. 全括号表达式分为单词Token列表：
   - Token分为括号（），操作符+-*/和操作数0-9
   - 左括号就是表达式的开始，右括号表示表达式的结束
2. 创建表达式解析树，规则如下：
   - 创建空树，当前节点为根节点
   - 读入左括号，创建左子节点，当前节点指针下降至左子节点
   - 读入操作数，当前节点设置为该数，指针上升到父节点
   - 读入操作符，当前节点设置为该操作符，创建右子节点，当前节点指针下降至右子节点
   - 读入右括号，指针上升至父节点
3. 使用解析树求值：由于二叉树是一种递归数据结构，可以设计递归的evaluate函数进行计算
   - 基本结束条件：叶节点作为根节点时，其数据项即为子表达式树的值
   - 缩小规模：将表达式树分为左子树，右子树
   - 调用自身：调用自身计算左子树与右子树的值，将左右子树的值依据根节点的操作符计算求值


### 4. 遍历Traversals

- 前序遍历preorder：先访问根节点，再递归地前序访问左子树，最后前序访问右子树


> 举例说明以下树的三种遍历方式
>
> <img src="/Users/rocher/Library/Application Support/typora-user-images/image-20240416204831011.png" alt="image-20240416204831011" style="zoom:50%;" />
>
> 前序遍历：7、8、11、18、17、12、22、19、9、14、10
>
> 中序遍历：18、11、17、8、22、19、12、7、14、10、9
>
> 后序遍历：18、17、11、22、19、12、8、14、10、9、7

### 5. 平衡二叉树

平衡二叉树，除叶节点所在层外，所有层都达到了最大节点数量，并且叶节点从左至右紧密排列

### 6. 二叉查找树

比父节点小的key都出现在左子树，比父节点大的key都出现在右子树

### 7. 任务目标：

- 从全括号表达式构建解析树
- 利用解析树对表达式求值
- 从解析树恢复原表达式的全括号字符串形式

在新key插入时一直保持平衡的二叉查找树，即平衡二叉查找树。

> 平衡因子balance factor：在AVL树的实现中，需要对每个节点跟踪平衡因子参数，其定义为左右子树的高度差
>
> ​			balanceFactor = height(leftSubTree) - height(rightSubTree)
>
> 若平衡因子为正，称为左重left-heavy，为负则称为右重right-heavy，为零则为平衡balanced。

如果一个二叉查找树的每个节点的平衡因子都在[-1, 0, 1]中，则该二叉查找树就是一个AVL树。

#### 7.1 插入元素

1. 将元素按照二叉搜索树的方法进行插入，即比节点大就下沉到节点右侧，比节点小就下沉到节点左侧，直至插入完成，记录插入路径

2. 沿插入路径逐级回溯检查，观察每个节点的平衡因子是否为[-1, 0, 1]

3. 当某个节点平衡因子不为[-1, 0, 1]时，针对插入的不同情况执行不同的调整策略

#### 7.2 删除元素

首先对元素进行查询，获取元素所在位置，再进行删除，此时待删除元素共有三种状态：无子树、有一个子树以及有两个子树。

1. 删除无子树的元素：直接删除
2. 删除有一个子树的元素：删除后，子树继承其位置
3. 删除有两个子树的元素：寻找该元素的后驱元素（即整个搜索树按顺序排列元素时，该元素的下一个元素），使用后驱元素替换该元素。

删除步骤完成后，同样需要沿路径进行调整，调整方法与插入时相同，进行“左旋”“右旋”“双旋”。判断的依据是观察哪一子树最为“突出”：

## 总结
看这个视频：https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428

核心就是插入和删除后如何通过“旋转”来维持平衡。核心是通过平衡因子来判断类型，然后进行旋转。右重左旋，左重右旋，从下往上。
左旋 ：把右孩子提上来，自己降下去做左孩子
右旋 ：把左孩子提上来，自己降下去做右孩子

当插入或删除一个节点后，我们从该节点开始向上回溯到根，检查路径上每个节点的 BF。我们把第一个变得不平衡的节点（BF 变为 +2 或 -2）称为 Z。
情况一：LL（左-左）型：如何识别 (失衡路径)： 新节点插入在 Z 节点的左子树 (L) 的左子树 (L) 中。
平衡因子特征：Z 节点的 BF = +2 （左重），Z 的左子节点（紧挨着的那个） Y 的 BF = +1 （也是左重）
解决方法： 对 Z 节点进行 1 次右旋 (Right Rotation)。

情况三：LR（左-右）型：如何识别 (失衡路径)： 新节点插入在 Z 节点的左子树 (L) 的右子树 (R) 中。
平衡因子特征：Z 节点的 BF = +2 （左重），Z 的左子节点 Y 的 BF = -1 （变为右重）
解决方法：先对 Y 节点进行 1 次左旋 (变为 LL 型)，再对 Z 节点进行 1 次右旋。

删除 (Deletion) 操作
步骤 1：标准删除

和普通 BST 一样删除节点（分 0、1、2 个子节点三种情况处理）。

步骤 2：回溯检查 BF

从被删除节点的父节点（或者，如果是“替换法”删除，则从实际被摘除的那个节点的父节点）开始，向上回溯到根。

沿途更新高度并检查 BF。

步骤 3：定位与旋转

重要区别： 删除操作可能需要多次旋转。你可能在 Z 点旋转一次后，Z 的父节点又失衡了，你需要继续向上检查，直到根节点。


## 所涉及概念系统性总结：
🌱 阶段0：数组（Array）
意义：O(1) 随机访问，CPU cache 友好。
痛点：插入/删除 O(n)，容量固定。
→ 需要 链表 做“弹性存储”。
🌿 阶段1：链表（Linked List）
优化：插入/删除 O(1)，动态大小。
痛点：没有随机访问，搜索 O(n)；内存不连续。
→ 需要 栈/队列 给“操作顺序”立规矩。
🌲 阶段2：栈 & 队列（Stack / Queue）
意义：LIFO/FIFO 语义，函数调用、缓冲、BFS/DFS 基底。
痛点：只能在一端操作，无法快速“找最小”或“查中间”。
→ 需要 树 带来层次关系。
🌳 阶段3：树（Tree）—— 突破线性
意义：层次结构，O(log n) 搜索（若平衡）。
痛点：普通二叉树可能退化成链表（高度 = n）。
→ 需要 BST 给节点排大小序。
🌴 阶段4：二叉搜索树（BST）
优化：左 < 根 < 右，中序 = 升序，查找/插入/删除 平均 O(log n)。
痛点：插入有序序列 → 链式退化，最坏 O(n)。
→ 需要 平衡 机制。
🌲🌲 阶段5：AVL 树（严格平衡）
优化：每个节点左右高度差 ≤ 1，永远 O(log n)。
痛点：插入/删除要旋转，维护成本 高；频繁更新场景常数大。
→ 需要 “差不多平衡” 结构（红黑、Treap、Splay）。
🌿🌡️ 阶段7：堆（Heap）/ 优先队列
优化：完全二叉树 + 堆序，O(1) 取最值，O(log n) 插入/删除最值。
痛点：无法快速查找“非最值”元素；无全局顺序。
→ 需要 既能最值又能遍历有序 的混合结构（偶尔堆 + 树配合使用）。
🌸 阶段8：表达式解析树（Expression Tree）
意义：把 中缀表达式 转成树，后序 = 逆波兰，易求值；前序加括号还原全串。
痛点：仅针对表达式场景；一般搜索/排序不会用它。
→ 专用 DSL，与通用数据结构互补。
🌼 阶段9：图（Graph）
突破树：“多对多”关系，树只是 无环连通 的特例。
痛点：无环 → 可能有环路、负权、连通分量等新问题。
→ 需要 DFS/BFS/Dijkstra/MST 等算法族解决。


| 维度             | 普通树 (Tree)      | 二叉搜索树 (BST)     | AVL 树                               |
| ------------     | ----------        | ---------------      | ----------------------------------- |
| **本质**         | 任意分叉 + 无环     | **二叉** + **有序** | **二叉 + 有序 + 严格平衡**                  |
| **节点顺序**     | 无要求             | 左 < 根 < 右         | 左 < 根 < 右 **且** 平衡因子 ∈ { -1, 0, 1 } |
| **平衡机制**     | 无                 | 无                   | 每次插入/删除后 **自动旋转**                   |
| **最坏高度**     | n（链表也可看成树） | n（有序插入退化成链）     | **log₂n**（严格平衡）                     |
| **查找/插入/删除** | O(n)             | O(n)（退化时）       | **O(log n)** 稳定                     |
| **旋转次数**     | 0                  | 0                   | **最多 1 次（插入）** 或 **一路向上（删除）**       |
| **使用场景**     | 表示层次即可        | 数据无序、查询少      | **查询频繁、需稳定 log n**                  |


类型	子节点数	排序规则	   平衡性   	查找效率	主要用途
普通树	任意	    无	          无保证	   O(n)	      文件系统、组织结构
二叉树 	≤ 2	        无	          无保证	   O(n)	      表达式树、堆的基础
BST	    ≤ 2       	左 < 根 < 右  无保证	  平均 O(log n)，最坏 O(n)	有序数据存储
AVL 树	≤ 2	        左 < 根 < 右  严格平衡	  O(log n) 	     需要快速查找的场景

二叉树 是 普通树 的特例（限制子节点数 ≤ 2）
BST 是 二叉树 的特例（增加排序约束）
AVL 树 是 BST 的特例（增加平衡约束）

数组快但硬，链表软但慢；BST 会驼背，AVL 强行矫正；堆只盯最值，图放飞自我；表达式树是数学课代表，专职括号表达式。

堆是一种特殊的完全二叉树，并且满足堆性质。两种类型：
最小堆：每个节点的值 ≤ 其子节点的值（根最小）
最大堆：每个节点的值 ≥ 其子节点的值（根最大）


# 总体关联：普通树（任意分支） -- 二叉树（只有2个分支）-- 堆（完全二叉树+只有大根和小根堆） -- 二叉搜索树 (BST，增加了左 < 根 < 右的约束) -- AVL（增加平衡因子）


## II. Priority Queue

### 1.定义

普通队列为先进先出FIFO，其变体**优先队列**满足：

- 优先队列的出队与队列相同，即队首出队
- 优先队列内部，数据项的次序由优先级决定：高优先级的数据项排在队首，低优先级的数据项排在队尾

### 2. 实现

> 1. 插入push：根据优先级排序，插入对应位置
> 2. 弹出优先级最高元素pop：弹出队首
> 3. 获取优先级最高的元素peek：获取队首

## III. Heap and Heapsort

### 1.堆Heap

#### 1.1 定义

堆在形式上是一种平衡二叉树，其元素按如下顺序排列：

- maxHeap：父节点大于子节点，从根节点出发的任意路径，遍历的元素为降序排列
- minHeap：父节点小于子节点，从根节点出发的任意路径，遍历的元素为升序排列

![image-20240416214212763](/Users/rocher/Library/Application Support/typora-user-images/image-20240416214212763.png)

#### 1.2 实现

以minHeap为例，实现对heap中元素的插入、删除等操作

> - 插入insert(key)：
>
>   首先将待插入的key放置于叶节点层的最右一个叶节点的右侧，沿着朝向根节点的路径逐步上浮，如果父节点比当前key大，则将二者对调，直到父节点小于当前key，此操作不会影响其他路径节点的堆次序
>
> - 删除最小removeMin():
>
>   将原根节点删除，并将叶节点层的最右侧叶节点放于根节点位置，若子节点均小于当前节点，则要对当前节点进行下沉，下沉路径为：比较左右子节点大小，与较小的节点进行对调
>
> - 从无序表生成堆buildHeap(list):
>
>   如果使用insert方法将数据项逐个插入堆中，总时间复杂度为$O(n\log n)$，而使用下沉路径则可以将复杂度将为$O(n)$​. 即首先使用无序表构建一个平衡二叉树，对所有父节点进行下沉操作

### 2. 堆排序HeapSort

> 过程
>
> 1. 首先从无序列表构建一个堆
> 2. 取堆顶元素放入最终输出的排序队列中
> 3. 将最右侧的叶节点放入堆顶，再次使用下沉方法构建新堆
> 4. 重复2-3，直至堆剩余最后一个元素

## IV. Merge-Sort and Quick-Sort

### 1. Merge Sort

归并排序在排序中使用了分治策略与递归算法：将数据表持续分裂为两半，对两半再分别进行归并排序

- 基本结束条件：数据表中仅包含1个数据项
- 缩小规模：将数据表分为相等的两半
- 调用自身：将两半分别调用自身排序，再将排好序的两半进行归并，得到排好的数据表


>  **复杂度分析**：算法可以看作由两个过程组成，即分裂和归并
>
> - 分裂：每次分割一半，即$2^i=n$，故复杂度为$O(\log n)$；
> - 归并：在分裂出的每个部分中，所有数据项都会被比较和放置一次，所以是线性复杂度$O(n)$
>
> 因此，总时间复杂度为$O(n\log n)$

### 2. Quick Sort

快速排序依据一个“中值”数据项把数据表分为两半，再对每部分分别进行快速排序

- 如果要保证两半有相同的数据量，则需要计算中位数，同样存在计算开销。因此，可以选取第一个数作为中值，不一定保证划分的两半部分数据量相同
- 递归的三要素：
  - 基本结束条件：列表中仅有1个数据项
  - 缩小规模：根据中值将数据表分为两半，最好情况是相等规模的两半
  - 调用自身：将两半分别调用自身进行排序
- 分裂数据表
  - 目标：找到中值应该放置于表中的位置
  - 方法：设置左右标
    - 左标右移，直到碰到比中值大的数据项；右标左移，直到碰到比中值小的数据项
    - 交换左右标的数据项（这时大的数据就被放在右侧，小的就被放在左侧）
    - 当左标移动到右标的右侧时停止移动，右标的位置就是插入中值的位置
    - 将中值和该位置数据交换，分裂完成
https://www.bilibili.com/video/BV1j841197rQ/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428


> **复杂度分析**：该过程分为分裂和移动两部分
>
> - 分裂：如果总能把数据表分成相等的两部分，则复杂度为$O(\log n)$
> - 移动：此过程需要将每项都与中值进行对比，复杂度为$O(n)$
>
> 因此，总时间复杂度为$O(n\log n)$​​
>
> 此外，如果中值过于偏离实际的中位数，会造成两端数据量不平衡，极端情况下时间复杂度会退化到$O(n^2)$

## V. Recursion, Devide-and-Conquer, Greedy
Recursion: 用 函数自我调用 把大问题拆成 结构相同但规模更小 的子问题。
Devide-and-Conquer: 当 子问题独立 且 解可合并 时，递归自然升级为 Divide-and-Conquer。
Greedy: 当 Combine 步骤可以省略（局部最优 = 全局最优）时，分治退化为 Greedy → 更快、更简单。

## VI. Mathemetical Induction
https://www.bilibili.com/video/BV1pF411Q7Mz/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428

### 第一类数学归纳：
| 步骤                              | 内容                             | 写法模板                              |
| ----------------------------      | ----------------------          | --------------------------------- |
| **Ⅰ. 基础步 (Base Case)**        | 验证 **n=1**（或最小起点）成立    | “当 n=1 时，左=…=右，故 P(1) 真。”         |
| **Ⅱ. 归纳假设 (I.H.)**           | 假设 **n=k** 时成立              | “假设 P(k) 成立，即 …”                  |
| **Ⅲ. 归纳递推 (Inductive Step)** | 用 P(k) 推出 **n=k+1** 成立      | “考虑 n=k+1，左=…+P(k)⇒右，故 P(k+1) 真。” |
| **Ⅳ. 结论**                      | 由数学归纳法，命题得证            | “根据数学归纳法，P(n) 对所有正整数 n 成立。”       |


## VII. Dynamic Programming

动态规划方法，从最简单的情况下的最优解开始，逐步递增，直到获得所需情况下的最优解，在递增过程中，需要设法保证每一步的递增都是最优解：

- 问题的最优解已经包含了更小子规模问题的最优解，这是能够使用动态规划的必要条件

> 案例一：找零问题。假设目前有[1, 5, 10, 25, 50]种类的硬币，求出指定找零数目下所需的最小硬币数量
>
> 问题分析：
>
> 1. 首先考虑找零钱数为1，2，... 情况下的最少硬币数量，例如1元-1个，2元-2个，...，5元-1个
> 2. 如果计算11元的兑换方法，做如下几步：
>    - 首先减1元硬币，剩下10元的最优解为1
>    - 然后减5元硬币，剩下6元的最优解为2
>    - 然后减10元硬币，剩下1元的最优解为1
>    - 比较上述三种情况，最优解为1+1=2
> 3. 因此，算法的基本原理应该是：使用所找的钱数减去硬币列表中的每个硬币，获得剩余钱数下的最优解，逐步缩减问题规模到最小规模
>
> 程序实现
>
> ```python
> def dpMakeChange(coinValueList, change):
>     # minCoins列表用于存储每种钱数下最少的硬币数量方便查表
>     minCoins = [0] * (change + 1) 
>     # 从1分钱开始，逐渐增加钱数直到目标钱数，算出每种情况下的最小硬币数
>     for money in range(1, change + 1):
>         coinCounts = money   # 最复杂的情况就是全都用1分钱，所以有cents个硬币
>         # 遍历硬币面值小于等于目标钱数的所有硬币面值
>         for j in [c for c in coinValueList if c <= cents]:
>           	# 目标零钱减去单个硬币面值即为所剩待找零钱，查表比较待找零钱的最优解与目前的硬币数
>             if minCoins[cents - j] + 1 < coinCounts:        
>                 coinCounts = minCoins[cents - j] + 1# 取两者最小为待找的硬币数量
>         minCoins[cents] = coinCounts# 将每种情况所需的最小硬币数量记录在minCoins列表中
>     return minCoins[change]
> ```
>
>  
>
> 案例二：博物馆盗贼问题。面对五件宝物，分别具有重量和价值，如何安排满载20kg的背包，使得所装物品价值最高？物品对应的重量（kg）和价值（万元）如下：1. [2, 3]; 2. [3, 4]; 3. [4, 8]; 4. [5, 8]; 5. [9, 10]
>
> 问题分析： 记$V(i, W)$为前$i$个宝物中，总重不超过$W$​的重量所能达到的最大价值。
>
> - 如果在获取$i-1$件时，背包已经超重，那么$V(i, W)=V(i-1,W)$，此时无法再加入宝物
> - 如果在获取第$i$件时没有超重，那么可以获取第$i$件，而前$i-1$件的价值就是$V(i-1, W-W_i)$，故而加上第i件后的总价值就是$V(i-1, W-W_i)+v_i$
> - 因此，$V(i, W)=\max\{V(i-1,W), V(i-1, W-W_i)+v_i\}$
>
> 所以问题变为从$V(1,1)$计算到$V(5,20)$。这里有两个变量，即应在不同拿取物品$i$条件下，让最大负重$W$从1至20，记录每种情况的最大价值并存储于二维表格中。注意到，在该二维数据表中每个数据仅依赖于其左侧或上侧的数据，例如$V(5,5)$，由于第5件重量9kg已经超重，因此
> $$
> V(5,5)=V(4,5)=\max\{V(3,5), V(3,0)+v_4\}
> $$
> 即每一步的状态都能由已经计算过的前集中状态得到。
>
> 程序实现：
>
> ```python
> def museumTheft(trList, maxWeight):
>     
>     # 创建一个二维列表用于保存每个状态下的最优解
>     value = {(i, w): 0 for i in range(len(trList)) for w in range(maxWeight+1)}
> 		# 从拿前1个宝物开始，遍历到拿前i个宝物，直到拿所有宝物
>     for i in range(1, len(trList)):     
>         for w in range(1, maxWeight+1):     #载重量从1开始，直到最大载重量
>           	# 如果想拿第i个宝物的重量超过了当前的背包载重量
>             if trList[i]['w'] > w:                  
>                 value[(i, w)] = value[(i-1, w)]     # 无法拿取，退回至拿前i-1宝物的情况
>             # 如果第i个宝物没有超重
>             else:
>               	# 不拿当前宝物，退回至前i-1宝物的情况
>                 dontloadCurrent = value[(i - 1, w)]
>                 # 拿当前宝物
>                 loadCurrent = value[(i-1, w-trList[i]['w'])] + trList[i]['v']
>                 # 比较二者最大值
>                 value[(i, w)] = max(dontloadCurrent, loadCurrent)  
>     return value[(len(trList) - 1, maxWeight)]      # 返回结果
> 
> maxWeight = 20
> # 使用字典存储宝物的重量价值信息，首位索引置空匹配函数代码
> treasure = [None, {'w': 2, 'v': 3}, {'w': 3, 'v': 4}, {'w': 4, 'v': 8}, {'w': 5, 'v': 8}, {'w': 9, 'v': 10}]
> 
> print(museumTheft(treasure, maxWeight))
> ```



## VIII. Graph Traversals: BFS and DFS

### 1. 图Graph

#### 1.1 相关术语

- 顶点Vertex或节点Node：图的基本组成部分，具有名称标识key，携带数据项
- 边Edge：作为两个节点间关系的表示，根据是否带有方向，所构成的图称为有向图/无向图
- 权重Weight：从一个节点到另一个节点的“代价”，从而给边赋权
- 路径Path：由边依次连接的顶点序列，路径长度为边的数量（无权）或边权重之和（有权）
- 圈Cycle：首尾顶点相同的路径
- 有向无环图DAG：有向图中不存在任何圈路径，则称为DAG

#### 1.2 定义

一个图G被定义为$G=(V,E)$，其中：

- V是顶点的集合，E是边的集合，E中的每条边$e=(v,w)$，其中v和w都是V中的顶点
- 如果是赋权图，可以在e中添加权重分量

#### 1.3 抽象数据类型

- Graph(): 创建一个空的图
- addNode(node): 将顶点node加入图中
- addEdge(fromNode, toNode)：添加有向边
- addEdge(fromNode, toNode, weight)：添加带权有向边
- getNode(nodeKey)：查找名称为nodeKey的顶点
- getNodes()：返回所有顶点列表
- in：判断顶点是否在图中

#### 1.4 实现方式：邻接矩阵与邻接表

##### 1.4.1 邻接矩阵

邻接矩阵的每行每列都代表图中的顶点，如果两个顶点之间有边相连，设定行列值为权重或1，无边相连则设定行列值为0。邻接矩阵优点在于方便理解及实现，缺点在于存储矩阵过于稀疏，效率较低。

##### 1.4.2 邻接列表

维护一个包含所有顶点的主列表master list，主列表中的每个顶点，再关联一个与自身有边相连的所有顶点的列表

<img src="/Users/rocher/Library/Application Support/typora-user-images/image-20240417202522483.png" alt="image-20240417202522483" style="zoom:40%;" />

### 2. 广度优先搜索BFS-Breadth First Search

给定图G，以及开始搜索的起始顶点s：

- BFS搜索所有从s可达到顶点的边
- 在达到更远距离k+1的顶点之前，首先要找到全部距离为k的顶点
- 可以想象以s为根，构建一棵树的过程，从顶部向下逐步增加层次 

### 3. 深度优先搜索DFS-Depth First Search
https://www.bilibili.com/video/BV17Y4UefEzs/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428



## IIX. Shortest Path: Dijkstra's Algorithm
https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428

![image-20240417214954644](/Users/rocher/Library/Application Support/typora-user-images/image-20240417214954644.png)

从0出发，计算到4的最短路径。

Dijkstra算法：首先列一张如下表格

| 节点 | 距离出发点0的距离 | 前一节点 |
| :--: | :---------------: | :------: |
|  0   |     $\infty$      |          |
|  1   |     $\infty$      |          |
|  2   |     $\infty$      |          |
|  3   |     $\infty$      |          |
|  4   |     $\infty$      |          |
|  5   |     $\infty$      |          |
|  6   |     $\infty$      |          |
|  7   |     $\infty$      |          |
|  8   |     $\infty$      |          |

首先看节点0，自己到自己距离为0，记录距离。检查所有节点中距离最短的节点，并做～标记。

继续沿着节点0进行，更新节点1和节点7的距离，节点1到初始节点距离为4，节点7为8，记录在表格中，并记录前一节点。继续比较未标记的节点，并～标记距离最小的节点（即节点1）。

更新节点1的邻近节点2和7，由起始点经过1至2的距离为12，记录；由起始点经过1至7的距离为15，大于已记录的距离，放弃。再次更新列表。比较所有未标记节点，使用～标记距离最小的节点（即节点7）。

更新节点7的邻近节点1，节点8和节点6，由于节点1已经标记故不考虑；节点8距离为15，记录；节点6距离为9，记录。比较所有未标记节点，使用～标记距离最小的节点（即节点6）。

更新节点6的邻近节点8和5，节点8的距离为15，无需更新；节点5的距离为11，记录。比较所有未标记节点，使用～标记距离最小的节点（即节点5）。

更新节点5的邻近节点2、3和4，节点2的距离为15，放弃；节点3的距离为25，记录；节点4的距离为21，记录。比较所有未标记节点，标记节点2。

| 节点 | 距离出发点0的距离 | 前一节点 |
| :--: | :---------------: | :------: |
| 0～  |         0         |          |
| 1～  |         4         |    0     |
| 2～  |        12         |    1     |
|  3   |        25         |    5     |
|  4   |        21         |    5     |
| 5 ～ |        11         |    6     |
| 6 ～ |         9         |    7     |
| 7 ～ |         8         |    0     |
|  8   |        15         |    7     |

更新节点2的邻近节点3和8，节点3的距离为19，小于原有的25，更新并记录；节点8的距离为14，小于原有的15，更新并记录。比较所有未标记节点，标记节点8。

节点8的邻近节点都已经标记，无需更新。继续比较所有未标记节点，标记节点3。

节点3的邻近节点4距离为28，大于原有的21，无需更新。最后标记节点4。

| 节点 | 距离出发点0的距离 | 前一节点 |
| :--: | :---------------: | :------: |
| 0 ～ |         0         |          |
| 1 ～ |         4         |    0     |
| 2 ～ |        12         |    1     |
| 3 ～ |        19         |    2     |
|  4   |        21         |    5     |
| 5 ～ |        11         |    6     |
| 6 ～ |         9         |    7     |
| 7 ～ |         8         |    0     |
| 8 ～ |        14         |    2     |

沿着节点4回溯其前一节点，再继续逐步回溯至起始点，可获得最短路径: $4 \leftarrow 5 \leftarrow 6 \leftarrow 7 \leftarrow 0$.

## IX. Minimum Spanning Tree: Kruskal's and Prim's 
https://www.bilibili.com/video/BV1wG411z79G/?spm_id_from=333.337.search-card.all.click&vd_source=8cef592ab47baea7fea36265d123d428

### 1. 最小生成树MXT

最小生成树，是指使用无环图构建的生成树中，权值和最小的树
用最小的总代价，把所有点连成一个无环连通图——Kruskal 玩边，Prim 玩点！

### 2. MST的构建

![image-20240417222817851](/Users/rocher/Library/Application Support/typora-user-images/image-20240417222817851.png)

#### 2.1 Kruskal算法：跳跃式加边

1. 将所有的边列出，并由小到大进行排列
2. 将所有的边按排列的顺序依次重新加回原图中，加入时判定图中是否存在环路，如果不存在则可以添加；如果存在则丢弃此边，跳跃式加边
3. 直到添加了n-1条边（n为顶点个数）时，算法结束，丢弃所有剩余的边。

![image-20240417223212222](/Users/rocher/Library/Application Support/typora-user-images/image-20240417223212222.png)

#### 2.2 Prim算法：逐个临近加点，和Dijkstra加点方式一样

Prim 关心“连树的最小边权”；Dijkstra 关心“离源点的最短路径长”。

首先构建两个集合，一个是进入最小生成树的顶点集合1，一个是尚未进入最小生成树的顶点集合2，Prim算法的原理就是取这两个集合区域中最小权值的边加入最小生成树，并将连接的顶点逐步加入集合1，直至集合2中不存在顶点。


###  整合
| 类别         | 核心任务                   | 关键数据结构               | 时间复杂度       | 口诀/易错点               |
| ------------ | ----------------          | --------------------   | --------------     | -------------------- |
| **BFS**      | 层序遍历 / 最短步数（权=1） | 队列 `queue`           | O(V+E)             | “一层一层扩散，先见最短”        |
| **DFS**      | 深序遍历 / 拓扑 / 判环     | 栈（递归隐式栈）             | O(V+E)         | “一条道走到黑，回溯再换路”       |
| **Dijkstra** | 单源最短路径（权≥0）        | 小根堆 `priority_queue` | O((V+E) log V)    | **累加**路径长，不能负权       |
| **Kruskal**  | 最小生成树                 | 并查集 `Union-Find`     | O(E log E)         | **边排序**，防环用并查        |
| **Prim**     | 最小生成树                 | 小根堆 + `vis[]`        | O((V+E) log V)     | **点扩张**，dist 存“最小单边” |


## 期末“纯概念”速通图——把 12 个知识点拍成 4 张思维快照，无代码，只看关系与关键词。背下来就能口述整张卷子。

----------------------------------------
快照 1　“排队 & 排序” 家族
----------------------------------------
1  Priority Queue（优先级队列）  
   本质：始终能 O(1) 取出“最优先”元素，插入/删除 O(log n)。  
   幕后：用 Binary Heap 实现；堆又是 Complete Binary Tree 的数组替身。

2  Heap / Heapsort  
   堆＝“父-子有序”的完全二叉树；根极值。  
   Heapsort＝Build-Heap + 不断“拔根+补洞”，天然 O(n log n)、空间 O(1)、不稳定。  
   关系：Heap 是 Priority Queue 的底层，也是排序算法的一种“巧用”。

3  Merge-Sort　Quick-Sort  
   共同标签：Divide-and-Conquer。  
   差异：  
   – Merge 先“温柔劈两半”再线性合并，稳定，需要额外数组。  
   – Quick 先“暴力切两刀”再递归，常数小、原地，但 pivot 选差会退化。  
   三者并列：Heap-sort、Merge-sort、Quick-sort 都是 O(n log n) Comparison-Sort 的代表。

----------------------------------------
快照 2　“搜索 & 组织” 家族
----------------------------------------
4  Binary Search Tree（BST）  
   规则：左 < 根 < 右，中序=升序。  
   性能：与树高成正比；随机数据 ≈ O(log n)，有序插入 → 链 O(n)。  
   进化：AVL / 红黑树＝“自平衡 BST”，把高锁在 log n，给 C++ map/set 当发动机。

----------------------------------------
快照 3　“算法思想” 三剑客
----------------------------------------
5  Recursion（递归）  
   自我调用 + 基例；所有“分治”都靠它落地。

6  Divide-and-Conquer（分治）  
   套路：分 → 治 → 合；典型：Merge-Sort、Quick-Sort、二分查找、最近点对。

7  Greedy（贪心）  
   套路：局部最优 → 全局最优；必须能“交换论证”或“归纳”证明。  
   同框：Dijkstra、Prim、Kruskal、Huffman 都是贪心，但各自证明策略不同。

8  Mathematical Induction（数学归纳法）  
   武器：基例 + 归纳假设 + 归纳步；用来证明递归正确、贪心最优、二分边界。

9  Dynamic Programming（DP）  
   核心：最优子结构 + 重叠子问题 + 状态转移。  
   与分治区别：子问题重叠，需要查表/记忆化避免重复。  
   与贪心区别：DP 保留“多条候选”，贪心只留“当下最好”。

----------------------------------------
快照 4　“图” 世界总览
----------------------------------------
10 Graph Traversal：BFS vs DFS  
    相同：O(V+E) 扫全图。  
    差异：  
    – BFS 用队列，层序扩散；权值为 1 时首次访问即最短步数。  
    – DFS 用栈/递归，一路探底；适合拓扑排序、判环、连通分量。

11 Shortest Path：Dijkstra  
    策略：贪心 + Priority Queue，每次“松弛”离源点最近的未确定点。  
    限制：边权非负；与 Prim 代码神似，但 Dijkstra 累加“整条路径”，Prim 只比较“单条连接边”。

12 Minimum Spanning Tree：Kruskal & Prim  
    共同目标：选 n-1 条边连通全图且总权最小、无环。  
    路线差异：  
    – Kruskal 按“边权”排序，用并查集防环；适合稀疏图。  
    – Prim 按“点扩张”，用堆选“离树最近点”；适合稠密图。  
    思想同源：都是贪心，且都能用“割性质”证明最优。

----------------------------------------
一句话串联
“堆”撑起优先队列，优先队列又驱动 Dijkstra 和 Prim；分治与 DP 都靠递归落地，但 DP 保存重叠子问题答案；BFS/DFS 是图世界的基础设施，所有路径与树问题都在它们之上做贪心或动态规划的文章。



